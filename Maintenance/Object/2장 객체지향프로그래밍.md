# 2장 객체지향 프로그래밍

## 요구사항

- 영화 예매 시스템을 이용해 보고 싶은 영화를 예매
- ‘영화’는 영화에 대한 기본 정보를 표현
- ‘상영’은 실제로 관객들이 영화를 관람하는 사건
- 할인정책과 할인 조건으로 할인 받을 수 있음

![image](https://github.com/yurim022/Today-I-Learn/assets/45115557/d315d277-eee4-4565-bafb-3be7ffc72065)


![image](https://github.com/yurim022/Today-I-Learn/assets/45115557/c79ff244-fb73-4303-acc7-5c473f6bb584)


</br></br>

## 객체지향 프로그래밍(Object Oriented Programming)

객체지향 패러다임으로의 전환은 **클래스가 아닌 객체에 초점**을 맞추는것.
아래 두가지를 중점적으로 집중한다.

**1) 어떤 클래스가 필요한지 고민하기 전에 어떤 객체들이 필요한지 고민**
   
클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것으로, 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지 먼저 결정.
이는 설계를 단순하고 깔끔하게 만든다.

   
**2) 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로**
   
훌륭한 협력이 훌륭한 객체를 낳고 훌륭한 객체가 훌륭한 클래스를 낳는다.

</br></br>

## 도메인(domain)

![image](https://github.com/yurim022/Today-I-Learn/assets/45115557/564eb550-93d0-4758-9902-dbe96b1bc745)

- 도메인 : 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야   
- 객체지향 패러다임이 강력한 이유는 요구사항을 분석하는 초기 단계부터 프로그램을 구현하는 마지막 단계까지 객체라는 동일한 추상화 기법을 따르기 때문    
- 요구사항과 프로그램을 객체라는 동일한 관점에서 볼 수 있기 때문에 **도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 매핑**됨.

![image](https://github.com/yurim022/Today-I-Learn/assets/45115557/6d69dbc9-3eb0-4d0c-91d1-d21f7af55663)

</br></br>


## 자율적인 객체

객체는 **상태(state)** 와 **행동(behavior)** 를 함께 가지는 복합적인 존재이며, 스스로 판단하고 해옹하는 **자율적인 존재**이다.   
- 캡슐화 : 데이터와 기능을 객체 내부로 함께 묶는 것 
- 접근제어(access control): 외부에서의 접근 제어. private,protected,private과 같은 접근 수정자(access modifier)를 제공
- 인터페이스와 구현의 분리(separation of interface and implementation) : 외부에 노출되는 메세지를 제외하고 실제 객체의 데이터와 private로직 구현을 분리시킴으로써 자율적인 객체를 만듬.
- 변경될 가능성이 있는 세부적인 구현 내용을 private 내에 감춤으로써 변경으로 인한 혼란 최소화

</br></br>

## 클래스 구현

**Screening.class**   
- 사용자들이 예매하는 대상인 상영 구현.
- 상영할 영화(movie), 순번(sequence), 상영 시작 시간(whenScreened) 인스턴수 변수로 가짐

```java
public class Screening {
    private Movie movie;
    private int sequence;
    private LocalDateTime whenScreened;

    public Screening(Movie movie, int sequence, LocalDateTime whenScreened) {
        this.movie = movie;
        this.sequence = sequence;
        this.whenScreened = whenScreened;
    }

    public LocalDateTime getStartTime() {
        return whenScreened;
    }

    public boolean isSequence(int sequence) {
        return this.sequence == sequence;
    }

    public Money getMovieFee() {
        return movie.getFee();
    }

    public Reservation reserve(Customer customer, int audienceCount) {
        return new Reservation(customer, this, calculateFee(audienceCount),
                audienceCount);
    }

    private Money calculateFee(int audienceCount) {
        return movie.calculateMovieFee(this).times(audienceCount);
    }
}
```
- calculateMovieFee는 1인당 구매요금이므로 관람 인원수만큼 곱해줌

</br></br>

**Reservation.class**   

```java
public class Reservation {
    private Customer customer;
    private Screening Screening;
    private Money fee;
    private int audienceCount;

    public Reservation(Customer customer, Screening Screening, Money fee, int audienceCount) {
        this.customer = customer;
        this.Screening = Screening;
        this.fee = fee;
        this.audienceCount = audienceCount;
    }
}
```

</br></br>

**Movie.class**   

```java
public class Movie {
    private String title;
    private Duration runningTime;
    private Money fee;
    private DiscountPolicy discountPolicy;

    public Movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy) {
        this.title = title;
        this.runningTime = runningTime;
        this.fee = fee;
        this.discountPolicy = discountPolicy;
    }

    public Money getFee() {
        return fee;
    }

    public Money calculateMovieFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```

</br></br>

**DiscountCondition.class**   

```java
public interface DiscountCondition {
    boolean isSatisfiedBy(Screening screening);
}
```


</br></br>

**DiscountPolicy.class**   

```java
public abstract class DiscountPolicy {
    private List<DiscountCondition> conditions = new ArrayList<>();

    public DiscountPolicy(DiscountCondition ... conditions) {
        this.conditions = Arrays.asList(conditions);
    }

    public Money calculateDiscountAmount(Screening screening) {
        for(DiscountCondition each : conditions) {
            if (each.isSatisfiedBy(screening)) {
                return getDiscountAmount(screening);
            }
        }

        return Money.ZERO;
    }

    abstract protected Money getDiscountAmount(Screening Screening);
}
```

</br></br>

**Customer.class**   

```java
public class Customer {
	private String name;
	private String id;
	
	public Customer(String name, String id) {
		this.id = id;
		this.name = name;
	}
}
```


</br></br>

**Money.class**   

```java
public class Money {
    public static final Money ZERO = Money.wons(0);

    private final BigDecimal amount;

    public static Money wons(long amount) {
        return new Money(BigDecimal.valueOf(amount));
    }

    public static Money wons(double amount) {
        return new Money(BigDecimal.valueOf(amount));
    }

    Money(BigDecimal amount) {
        this.amount = amount;
    }

    public Money plus(Money amount) {
        return new Money(this.amount.add(amount.amount));
    }

    public Money minus(Money amount) {
        return new Money(this.amount.subtract(amount.amount));
    }

    public Money times(double percent) {
        return new Money(this.amount.multiply(BigDecimal.valueOf(percent)));
    }

    public boolean isLessThan(Money other) {
        return amount.compareTo(other.amount) < 0;
    }

    public boolean isGreaterThanOrEqual(Money other) {
        return amount.compareTo(other.amount) >= 0;
    }

    public boolean equals(Object object) {
        if (this == object) {
            return true;
        }

        if (!(object instanceof Money)) {
            return false;
        }

        Money other = (Money)object;
        return Objects.equals(amount.doubleValue(), other.amount.doubleValue());
    }

    public int hashCode() {
        return Objects.hashCode(amount);
    }

    public String toString() {
        return amount.toString() + "원";
    }
}
```

- Money를 Long 타입으로 대체할 수 있지만, Money 처럼 금액과 관련되어 있다는 것을 표현할 수 없음
- 금액과 관련된 로직이 서로 다른 곳에 중복되어 구현되는 것을 막을 수 있음
- 의미를 명시적으로 표현하는 것은 전체적인 설계의 명확성과 유연성을 높임

</br>

**Screening, Reservation, Movie 사이의 협력**

![image](https://github.com/yurim022/Today-I-Learn/assets/45115557/298bc5d1-83d3-4f1c-8a28-dcd9f672adf1)

</br></br>

