# 2장 객체지향 프로그래밍

## 요구사항

- 영화 예매 시스템을 이용해 보고 싶은 영화를 예매
- ‘영화’는 영화에 대한 기본 정보를 표현
- ‘상영’은 실제로 관객들이 영화를 관람하는 사건
- 할인정책과 할인 조건으로 할인 받을 수 있음
- 할인정책은 금액할인, 비율할인 / 할인조건은 순번할인 , 기간 할인으로 나뉨

![image](https://github.com/yurim022/Today-I-Learn/assets/45115557/d315d277-eee4-4565-bafb-3be7ffc72065)


![image](https://github.com/yurim022/Today-I-Learn/assets/45115557/c79ff244-fb73-4303-acc7-5c473f6bb584)


</br></br>

## 객체지향 프로그래밍(Object Oriented Programming)

객체지향 패러다임으로의 전환은 **클래스가 아닌 객체에 초점**을 맞추는것.
아래 두가지를 중점적으로 집중한다.

**1) 어떤 클래스가 필요한지 고민하기 전에 어떤 객체들이 필요한지 고민**
   
클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것으로, 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지 먼저 결정.
이는 설계를 단순하고 깔끔하게 만든다.

   
**2) 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로**
   
훌륭한 협력이 훌륭한 객체를 낳고 훌륭한 객체가 훌륭한 클래스를 낳는다.

</br></br>

## 도메인(domain)

![image](https://github.com/yurim022/Today-I-Learn/assets/45115557/564eb550-93d0-4758-9902-dbe96b1bc745)

- 도메인 : 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야   
- 객체지향 패러다임이 강력한 이유는 요구사항을 분석하는 초기 단계부터 프로그램을 구현하는 마지막 단계까지 객체라는 동일한 추상화 기법을 따르기 때문    
- 요구사항과 프로그램을 객체라는 동일한 관점에서 볼 수 있기 때문에 **도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 매핑**됨.

![image](https://github.com/yurim022/Today-I-Learn/assets/45115557/6d69dbc9-3eb0-4d0c-91d1-d21f7af55663)

</br></br>


## 자율적인 객체

객체는 **상태(state)** 와 **행동(behavior)** 를 함께 가지는 복합적인 존재이며, 스스로 판단하고 해옹하는 **자율적인 존재**이다.   
- 캡슐화 : 데이터와 기능을 객체 내부로 함께 묶는 것 
- 접근제어(access control): 외부에서의 접근 제어. private,protected,private과 같은 접근 수정자(access modifier)를 제공
- 인터페이스와 구현의 분리(separation of interface and implementation) : 외부에 노출되는 메세지를 제외하고 실제 객체의 데이터와 private로직 구현을 분리시킴으로써 자율적인 객체를 만듬.
- 변경될 가능성이 있는 세부적인 구현 내용을 private 내에 감춤으로써 변경으로 인한 혼란 최소화

</br></br>

## 클래스 구현

**Screening.class**   
- 사용자들이 예매하는 대상인 상영 구현.
- 상영할 영화(movie), 순번(sequence), 상영 시작 시간(whenScreened) 인스턴수 변수로 가짐

```java
public class Screening {
    private Movie movie;
    private int sequence;
    private LocalDateTime whenScreened;

    public Screening(Movie movie, int sequence, LocalDateTime whenScreened) {
        this.movie = movie;
        this.sequence = sequence;
        this.whenScreened = whenScreened;
    }

    public LocalDateTime getStartTime() {
        return whenScreened;
    }

    public boolean isSequence(int sequence) {
        return this.sequence == sequence;
    }

    public Money getMovieFee() {
        return movie.getFee();
    }

    public Reservation reserve(Customer customer, int audienceCount) {
        return new Reservation(customer, this, calculateFee(audienceCount),
                audienceCount);
    }

    private Money calculateFee(int audienceCount) {
        return movie.calculateMovieFee(this).times(audienceCount);
    }
}
```
- calculateMovieFee는 1인당 구매요금이므로 관람 인원수만큼 곱해줌

</br></br>

**Reservation.class**   

```java
public class Reservation {
    private Customer customer;
    private Screening Screening;
    private Money fee;
    private int audienceCount;

    public Reservation(Customer customer, Screening Screening, Money fee, int audienceCount) {
        this.customer = customer;
        this.Screening = Screening;
        this.fee = fee;
        this.audienceCount = audienceCount;
    }
}
```

</br></br>

**Movie.class**   

```java
public class Movie {
    private String title;
    private Duration runningTime;
    private Money fee;
    private DiscountPolicy discountPolicy;

    public Movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy) {
        this.title = title;
        this.runningTime = runningTime;
        this.fee = fee;
        this.discountPolicy = discountPolicy;
    }

    public Money getFee() {
        return fee;
    }

    public Money calculateMovieFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```

</br></br>

**Customer.class**   

```java
public class Customer {
	private String name;
	private String id;
	
	public Customer(String name, String id) {
		this.id = id;
		this.name = name;
	}
}
```


</br></br>

**Money.class**   

```java
public class Money {
    public static final Money ZERO = Money.wons(0);

    private final BigDecimal amount;

    public static Money wons(long amount) {
        return new Money(BigDecimal.valueOf(amount));
    }

    public static Money wons(double amount) {
        return new Money(BigDecimal.valueOf(amount));
    }

    Money(BigDecimal amount) {
        this.amount = amount;
    }

    public Money plus(Money amount) {
        return new Money(this.amount.add(amount.amount));
    }

    public Money minus(Money amount) {
        return new Money(this.amount.subtract(amount.amount));
    }

    public Money times(double percent) {
        return new Money(this.amount.multiply(BigDecimal.valueOf(percent)));
    }

    public boolean isLessThan(Money other) {
        return amount.compareTo(other.amount) < 0;
    }

    public boolean isGreaterThanOrEqual(Money other) {
        return amount.compareTo(other.amount) >= 0;
    }

    public boolean equals(Object object) {
        if (this == object) {
            return true;
        }

        if (!(object instanceof Money)) {
            return false;
        }

        Money other = (Money)object;
        return Objects.equals(amount.doubleValue(), other.amount.doubleValue());
    }

    public int hashCode() {
        return Objects.hashCode(amount);
    }

    public String toString() {
        return amount.toString() + "원";
    }
}
```

- Money를 Long 타입으로 대체할 수 있지만, Money 처럼 금액과 관련되어 있다는 것을 표현할 수 없음
- 금액과 관련된 로직이 서로 다른 곳에 중복되어 구현되는 것을 막을 수 있음
- 의미를 명시적으로 표현하는 것은 전체적인 설계의 명확성과 유연성을 높임

</br>

**Screening, Reservation, Movie 사이의 협력**

![image](https://github.com/yurim022/Today-I-Learn/assets/45115557/298bc5d1-83d3-4f1c-8a28-dcd9f672adf1)

</br></br>

## 협력

- 메세지 전송(send a message) : 객체가 다른 객체와 상호작용
- 메세지 수신(receive a message) : 다른 객체에게 요청이 도착. 수신한 객체는 스스로 결정에 따라 자율적으로 메시지를 처리할 방법을 결정
- 메서드(method) : 수신된 메세지를 처리하기 위한 자신만의 방법

메세지와 메서드를 구분하는 것이 중요하다. 자율적인 객체는 interface에 노출된 message와 이를 처리하기 위한 method를 스스로 선택할 수 있어야 한다.

</br></br>

## 할인정책과 할인조건

**DiscountCondition.class**   

```java
public interface DiscountCondition {
    boolean isSatisfiedBy(Screening screening);
}
```


</br></br>

**DiscountPolicy.class**   

```java
public abstract class DiscountPolicy {
    private List<DiscountCondition> conditions = new ArrayList<>();

    public DiscountPolicy(DiscountCondition ... conditions) {
        this.conditions = Arrays.asList(conditions);
    }

    public Money calculateDiscountAmount(Screening screening) {
        for(DiscountCondition each : conditions) {
            if (each.isSatisfiedBy(screening)) {
                return getDiscountAmount(screening);
            }
        }

        return Money.ZERO;
    }

    abstract protected Money getDiscountAmount(Screening Screening);
}
```

</br></br>

Movie의 코드를 보면 어떤 할인정책을 사용하는지 관한 코드는 존재하지 않음. 단지 discountPolicy에게 전송할 뿐.
- 위 코드는 객체지향에서 중요한 **상속(inheritance)** 와 **다형성** 개념이 있음. 이는 **추상화(abstraction)** 원리 기반.
- DiscountPolicy 는 DiscountCondition의 리스트인 conditions를 인스턴스 변수로 가지기 때문에 하나의 할인 정책은 여러개의 할인 조건을 포함 할 수 있음.
- DiscountCondition의 isSatisfiedBy 가 할인조건을 만족하면 true 리턴
- **추상 메서드(abstract method)** getDiscountAmount 메서드를 호출해 할인 요금을 계산
- **TEMPLATE METHOD PATTERN** : 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에 위임하는 디자인 패턴

</br>

### DiscountCondition 구현
</br>

**PeriodCondition.class**   

```java
public class PeriodCondition implements DiscountCondition {
    private DayOfWeek dayOfWeek; //요일
    private LocalTime startTime; //시작시간
    private LocalTime endTime; //종료시간

    public PeriodCondition(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime) {
        this.dayOfWeek = dayOfWeek;
        this.startTime = startTime;
        this.endTime = endTime;
    }

    public boolean isSatisfiedBy(Screening screening) {
        return screening.getStartTime().getDayOfWeek().equals(dayOfWeek) &&
                startTime.compareTo(screening.getStartTime().toLocalTime()) <= 0 &&
                endTime.compareTo(screening.getStartTime().toLocalTime()) >= 0;
    }
}
```
- 상영 시작시간이 특정한 기간 안에 포함되는지 여부를 판단해 할인 여부를 결정

</br></br>

**SequenceCondition.class**   

```java
public class SequenceCondition implements DiscountCondition {
    private int sequence;

    public SequenceCondition(int sequence) {
        this.sequence = sequence;
    }

    public boolean isSatisfiedBy(Screening screening) {
        return screening.isSequence(sequence);
    }
}
```
- 파라미터로 전달된 screening의 상영 순번과 일치할 경우 할인 가능한 것으로 판단

</br></br>

### DiscountPolicy 상속
</br>

**AmountDiscountPolicy.class**   

```java
public class AmountDiscountPolicy extends DiscountPolicy {
    private Money discountAmount;

    public AmountDiscountPolicy(Money discountAmount, DiscountCondition... conditions) {
        super(conditions);
        this.discountAmount = discountAmount;
    }

    @Override
    protected Money getDiscountAmount(Screening screening) {
        return discountAmount;
    }
}
```

</br></br>

**PercentDiscountPolicy.class**   

```java
public class PercentDiscountPolicy extends DiscountPolicy {
    private double percent;

    public PercentDiscountPolicy(double percent, DiscountCondition... conditions) {
        super(conditions);
        this.percent = percent;
    }

    @Override
    protected Money getDiscountAmount(Screening screening) {
        return screening.getMovieFee().times(percent);
    }
}
```

</br></br>

**NoneDiscountPolicy.class**   

```java
public class NoneDiscountPolicy extends DiscountPolicy {
    @Override
    protected Money getDiscountAmount(Screening screening) {
        return Money.ZERO;
    }
}
```

</br></br>

## 컴파일 시간 의존성과 실행 시간 의존성

- Movie 클래스 어디에서도 할인 정책이 금액 할인 정책인지, 비율 할인 정책인지 판단하지 않음
- 영화 요금을 계산하기 위해서는 추상클래스인 DiscountPolicy가 아니라 AmountDiscountPolicy 와 PercentDiscountPolicy 인스턴스에 의존해야 함

```java
Movie avatar = new Movie("아바타", Duration.ofMinutes(120), Money.wons(10000), new PercentDiscountPolicy(0,1,...));
```

- 코드상에서 Movie는 DiscountPolicy에 의존하나 실행시점에는 Movie의 인스턴스는 AmountPolicy나 PercentDiscountPolicy에 의존함 (스프링에서는 어노테이션으로 지정 가능)
- 즉, 코드의 의존성과 실행시점의 의존성이 서로 다를 수 있음
- 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워지나, 유연성을 억제하면 재사용성과 확장 가능성은 낮아짐.

</br></br>

## 차이에 의한 프로그래밍 (programming by difference)

- 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법
- 상속을 이용하여 기존 클래스가 가지고 있는 모든 속성과 행동을 새로운 클래스에 포함시킴
- DiscountPolicy는 getDiscountAmount만 abstract 으로 구현한뒤 이를 어버라이딩 해서 행동을 수정한 좋은 예시

</br></br>

## 상속과 인터페이스
- 상속이 가치 있는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문
- 인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의
- 자식 클래스는 부모 클래스가 수신할 수 있는 모든 메시지를 수신할 수 있으므로 외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주 할 수 있음

```java
public class Movie {
    public Money calculateMovieFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```
- DiscountPolicy를 상속받는 AmountDiscountPolicy와 PercentDiscountPolicy는 calculateDiscountAmount 메시지를 수신할 수 있음
- 따라서 DiscountPolicy 대신 Movie와 협력 가능
- 이처럼 자식 클래스가 부모 클래스를 대신하는 것을 **업캐스팅(upcasting)** 이라 함

</br></br>

