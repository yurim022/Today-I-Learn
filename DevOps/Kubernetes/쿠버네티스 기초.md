# Why Kubernetes

![image](https://user-images.githubusercontent.com/45115557/197126988-5af8b98b-969a-425c-b29d-bb0e56b661ce.png)

</br>

- **Traditional Deployment**

한 물리서버에서 애플리케이션 리소스 한계를 정의할 방법이 없었기 때문에 **리소스 할당의 문제**가 발생했다. 하나의 물리서버에서 여러 애플리세이션을 실행하면 리소스 전부를 차지하는 인스턴스가 있을 수 있고 결과적으로 다른 애플리케이션의
성능이 저하될 수 있다. 

- **Virtualized Deployment**

가상화를 사용하여 VM간에 대플리케이션을 격리하고, **애플리케이션의 정보를 다른 애플리케이션으로부터 접근할 수 없도록 하여 보안성을 제공**할 수 있게 되었다. 
가상화를 통해 물리 리소스를 폐기 가능한(disposable) 가상머신 클러스터로 만들어 **애플리케이션 확장, 추가, 업데이트를 용이하게** 할 수 있다. 
각각의 VM은 별도의 OS를 가진다. 

- **Container Deployment**

컨테이너는 VM과 유사하지만, 격리 속성을 완화하여 **애플리케이션 간에 운영체제(OS)를 공유**한다. 이 때문에 컨테이너가 VM보다 더 가볍다.    
컨테이너는 VM과 마찬가지로 **자체 파일 시스템, CPU 점유율, 메모리, 프로세스 공간**을 가진다. 

</br>

## 컨테이너의 장점

* 애플리케이션 생성 : VM에 비해 컨테이너 이미지 생성이 쉽고 효율적임
* 지속적인 개발, 통합, 배포 : 주기적인 컨테이너 이미지 빌드 및 배포가 용이하며, 이미지의 불변성으로 효율적으로 롤백 가능 
* 개발과 운영 관심사 분리 : 배포 시점이 아닌 빌드/릴리스 시점에 이미지를 만들기 때문에 애플리케이션이 인프라스트럭처에서 분리됨
* 동일한 환경을 손쉽게 여러 머신에 설치가능
* 리소스의 효율적 사용 (Host의 OS kernel 사용)

</br>

## 쿠버네티스가 제공하는 것

사실 쿠버네티스는 분산처리 환경이 아니라면 꼭 필요하지 않다. 쿠버네티스는 컨테이너를 관리하고 가동 중지 시간이 없는지 확인하는 작업 ( 컨테이너가 다운되면 다른 컨테이너를 시작하는 등 )을 시스템에 의해
처리할 수 있도록 해준다. 애플리케이션의 확장과 장애 조치, 배포 패턴 등을 제공한다!

- **서비스 디스커버리와 로드밸런싱**




참고링크:   
[쿠버네티스 공식문서](https://kubernetes.io/ko/docs/concepts/overview/what-is-kubernetes/)
