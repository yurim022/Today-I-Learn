진행하는 서비스에서 DB Partitioning을 진행하게 되었다. 

## 파티션 하는 이유

- 데이터의 종류 :  원천(?),내역, 이력
- 데이터 중요도 : 원천 > 내역 > 이력
- 데이터의 양 : 원천 < 내역 < 이력

이력은 데이터가 사라져도 큰 이슈가 없으나, 내역은 어느정도 상용시 이슈가 있을 수 있는 데이터이며 ( 은행에선 입출금 내역 등 ) 이력은 정말 시간순대로 쌓이는 데이터들. 그 자체로 큰 의미가 없는 데이터들을 말한다. 

이력데이터에도 개인정보가 들어갈 수 있기 때문에 정부 방침에 따라 주기적으로 삭제해 주어야 한다. 이 때, 스캔을 하면서 특정 시간을 지난 데이터를 삭제하자면 시스템에 부하가 클 수 있다. 대신 파티션 테이블을 만들어 작게는 몇시간, 하루 부터 일주일, 달, 년 등의 단위로 테이블을 나눠놓으면 파티션 테이블을 drop하면 되기때문에 빠르게 데이터를 삭제할 수 있다.   

cf) 최근에는 외래키를 잘 사용하지 않는 추세이다. (물론 논리적인 결합은 설계되어 있고, 이를 로직 상 구현한다.) 외래키가 걸려있으면 테이블 구조 변경 시 제약이 많이 때문이다. 또 외래키 제약조건에 의해 부모키가 존재하는지 매번 스캔해야 하기 때문에 성능에도 좋지 않다. 해서, 이력이나 내역과 같이 중요도가 낮은 데이터들은 외래키 없이 논리적으로 구현하고 원천과 같이 중요한 데이터에만 외래키를 걸어 보안을 강화한다. (물론 금융권의 경우 내역도 중요하기 때문에 내역에도 외래키를 걸 가능성이 높다.)


## 파티션 조건

- Range Partitioning에선 대게 파티션은 time 관련값을 사용한다. 
- 파티션 키는 UNIQUE 조건을 만족해야 한다. 꼭 인덱스를 걸 필요는 없으나 당연히 걸면 빠르겠징!


## 파티션 종류

#### Horizontal Partitioning
![image](https://user-images.githubusercontent.com/45115557/172708980-113cb867-053b-4be1-b522-dcaeee9b1e17.png)


#### Vertical Partitioning

* 테이블의 컬럼을 기준으로 PARTITIONING
* 자주 사용하는 컬럼을 분리시켜 성능 향상
![image](https://user-images.githubusercontent.com/45115557/172709046-e16b5977-1379-489b-8d43-63821f276cd8.png)


## 방식

* Range Partitioning (연속적인 숫자나 날짜 기준)
* List Partitioning ( 데이터에 대한 명시적 제어 가능 ex) 한국,일본,중국 -> 아시아 / 노르웨이, 스웨덴, 핀란드 -> 북유럽 )
* Composite Partitioning (Partition의 Sub-Partitioning, 파티션의 결과 생성된 파티션이 너무 커져서 효과적으로 관리하기 위해 사용)
* Hash Partitioning (범위가 없는 데이터에 적합) 

Reference
https://nesoy.github.io/articles/2018-02/Database-Partitioning
